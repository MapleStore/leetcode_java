package darren.gong.leetcode;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class MinMalwareSpread_924 {
  public static void main(String[] args) {
    MinMalwareSpread_924 minMalwareSpread_924 = new MinMalwareSpread_924();
    minMalwareSpread_924.minMalwareSpread(new int[][]{{1,0,0,0,1,0,0,0,0,0,1},{0,1,0,1,0,0,0,0,0,0,0},{0,0,1,0,0,0,0,1,0,0,0},{0,1,0,1,0,1,0,0,0,0,0},{1,0,0,0,1,0,0,0,0,0,0},{0,0,0,1,0,1,0,0,1,1,0},{0,0,0,0,0,0,1,1,0,0,0},{0,0,1,0,0,0,1,1,0,0,0},{0,0,0,0,0,1,0,0,1,0,0},{0,0,0,0,0,1,0,0,0,1,0},{1,0,0,0,0,0,0,0,0,0,1}}, new int[]{7,8,6,2,3});
  }
  private int[][] graph;
  private int[] initial;
  private int n;
  public int minMalwareSpread(int[][] graph, int[] initial) {
    Arrays.sort(initial);
    this.graph = graph;
    this.initial = initial;
    this.n = graph.length;
    int min = Integer.MAX_VALUE;
    int result = 0;
    for (int removeNode : initial) {
      int errCount = spread(removeNode);
      if (errCount < min) {
        result = removeNode;
        min = errCount;
      }
    }
    return result;
  }
  private int spread(int remove) {
    int errCount = 0;
    Queue<Integer> queue = new LinkedList<>();
    boolean[] visited = new boolean[n];
    for (int errNode : initial) {
      if (errNode != remove) {
        queue.add(errNode);
        visited[errNode] = true;
      }
    }
    while (!queue.isEmpty()) {
      int current = queue.poll();
      errCount++;
      for (int next = 0; next < n; next++) {
        if (graph[current][next] == 1 && !visited[next]) {
          queue.add(next);
          visited[next] = true;
        }
      }
    }
    return errCount;
  }
}
